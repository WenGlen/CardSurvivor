1. 順序依賴堆疊邏輯：快照機制 (Snapshot Mechanism)
為了達成「後面的卡片不套用前面效果」，我們不能使用傳統的 Base * (1 + Sum) 公式。我們必須將技能視為一個不斷演化的物件。

核心邏輯：
技能實體 (Skill Instance)：每個卡槽有一個「當前屬性快照」。

屬性卡 (Stat Modifier)：直接修改快照中的數值（例如：current_speed *= 1.2）。

衍生卡 (Spawn/Split Modifier)：根據「目前的快照」產生新的子彈或物件。

舉例說明：電球技能

初始狀態：1 顆電球，速度 100。

卡片 A (速度 +20%)：將「當前快照」的速度改為 120。

卡片 B (數量 +1)：根據「當前快照」再產生 1 顆電球。此時你有：

電球 1 (速度 120)

電球 2 (速度 120)

卡片 C (速度 +50%)：此時的邏輯可以有兩種設計（依你的需求而定）：

設計 A (整體演化)：修改快照，未來的電球都會變快，但舊的不變。

設計 B (精確排序)：這張卡只對「下一個產生的電球」生效，或是對「目前已存在的特定序位」生效。

照你的描述： 如果先疊加速度，再疊數量，第二顆不套用。這代表「加成卡」應該只作用於「主體」，而「數量卡」產生的副本會繼承主體「那一刻」的狀態，但之後的加成只會給到主體。

2. 技能參數規劃 (Skill Parameters)
為了應對多樣化的技能（冰錐、電球、光束、火焰），我們需要定義一套通用的參數池。

A. 基礎物理參數 (Base Physics)
damage (傷害)：基礎數值。

cooldown (冷卻)：兩次攻擊間的間隔。

duration (持續時間)：子彈消失前的時間（對電球、火焰尤為重要）。

speed (移動/旋轉速度)：直線飛行速度或環繞旋轉速度。

size (大小/範圍)：子彈縮放比例或扇形角度（如火焰）。

B. 特效與行為參數 (Behavioral)
pierceCount (穿透力)：子彈可以穿過多少怪物。

bounceCount (彈跳次數)：碰到牆壁或怪物是否彈跳。

splitCount (分裂數)：擊中後是否產生小碎片。

spreadAngle (散射角度)：多發子彈時的張開角度。

C. 元素屬性 (Elemental Tags)
tag：ICE, LIGHTNING, FIRE, BEAM...

statusEffect：附加效果（減速、感電、燃燒）。

3. TypeScript 資料結構設計
這部分是給 Agent 的核心參考代碼，定義了卡片如何「修飾」技能。

TypeScript
// 定義卡片效果的操作類型
type ModifierOp = 'MULTIPLY' | 'ADD' | 'SET' | 'SPAWN_COPY';

interface CardEffect {
  property: keyof SkillStats; // 要修改哪一個參數
  operation: ModifierOp;
  value: number;
}

interface SkillStats {
  damage: number;
  speed: number;
  range: number;
  count: number;
  // ... 其他參數
}

// 技能卡片的定義
interface Card {
  id: string;
  name: string;
  type: 'BASE' | 'MODIFIER'; 
  effects: CardEffect[];
}

// 最終戰鬥中實體化的技能物件
class ActiveSkill {
  baseStats: SkillStats;      // 初始數值
  instances: SkillStats[];   // 每一顆子彈/物件的獨立數值快照 (解決順序堆疊的核心)
  
  applyCard(card: Card) {
    // 這裡實作你的順序邏輯：
    // 如果是加成卡，可能只修飾 instances[0] (主體)
    // 如果是數量卡，則 push 一個當前 instances[0] 的副本到陣列中
  }
}

---
---
---


## 1. 核心機制：順序性堆疊（Sequential Stacking）詳解

在代碼邏輯中，這被稱為 **「線性演化模型」**。每個卡槽（Slot）維護一個 `CurrentState`（當前狀態物件）。

### 運作邏輯

1. **初始啟動**：玩家放入「主動技能卡」，產生 `Instance[0]`（母體）。
2. **屬性強化（Buff）**：放入強化卡（如傷害+50%），會直接修改 `CurrentState` 的數值。
3. **衍生產生（Spawn）**：放入數量卡（如數量+1），系統會根據 **「那一刻」** 的 `CurrentState` 複製出一份 `Instance[1]`（子體）。
4. **後續隔離**：在此之後放入的強化卡，只會修改 `CurrentState`（母體），而不會去動已經產生的 `Instance[1]`。

> **平衡性關鍵：**
> * **先強化後複製**：得到兩顆強力的子彈（高成本，因為數量卡通常難得）。
> * **先複製後強化**：得到一顆強力的主彈 + 一顆弱小的副彈（適合用於觸發特效或擋刀）。
> 
> 

---

## 2. 技能卡片全書與平衡參數表

| 類型 | 技能名稱 | 核心機制 | 主要參數 | 策略玩法 (順序影響) |
| --- | --- | --- | --- | --- |
| **投射** | **冰錐** | 直線發射，有機率貫穿 |  | 先疊 Pierce 再疊數量：每發都能穿透。先疊數量再疊 Pierce：只有第一發能穿透。 |
| **環繞** | **電球** | 繞身旋轉，持續觸碰傷害 |  | 先疊速度再疊數量：所有球同步高速旋轉。後疊數量：形成內外圈不同速的「防禦網」。 |
| **持續** | **光束** | 鎖定最近敵人持續照射 |  | 先疊寬度：產生粗大的主光束。後疊數量：主光束粗，副光束細，適合掃蕩殘血。 |
| **近戰** | **火焰** | 扇形噴射，附帶灼燒 |  | 先疊角度：噴射範圍變大。先疊數量：產生多個窄角度火焰，形成離散的「火網」。 |
| **區域** | **毒霧** | 腳下生成持續傷害區域 |  | 先疊減速：產生泥淖區。先疊數量：一個大泥淖區配上幾個小傷害區。 |
| **位移** | **衝撞** | 向搖桿方向衝刺 |  | 先疊距離：長程衝撞。後疊數量：連段衝撞，但第二次之後的衝撞傷害較低。 |
| **控制** | **風刃** | 擊退敵人，傷害隨距離減 |  | 先疊擊退：保命神技。先疊數量：只有第一發能推開怪，後面是純補傷害。 |
| **束縛** | **水球** | 囚禁複數敵人至死 |  | 先疊容量：一次關住一群精英怪。後疊數量：主球關大怪，副球關雜魚。 |
| **陷阱** | **崩落** | 定點造成敵方卡死 |  | 先疊施法距離：遠程控制。後疊數量：能在腳下補放一個保命小陷阱。 |
| **概率** | **詛咒** | 極低機率直接斬殺 |  | 先疊機率：針對 BOSS。先疊數量：多發小機率，拼「抽獎」次數。 |
| **策略** | **魅惑** | 轉換敵方陣營 |  | 先疊 Buff：魅惑一隻變超強戰友。先疊數量：組建一支弱小的傀儡軍團。 |
| **聚怪** | **黑洞** | 強力吸引中心點 |  | 先疊吸力：瞬間聚怪。先疊數量：大黑洞吸怪，小黑洞在旁持續干擾。 |
| **鏈接** | **連鎖閃電** | 敵人跳躍式傷害 |  | 先疊跳躍：清理大群怪。先疊數量：第一發跳得遠，後續發射的只會電附近的怪。 |

---

## 3. 整體平衡性考量 (General Balancing)

為了防止玩家過度強大導致遊戲無趣，我們引入以下平衡軸線：

### A. 資源消耗限制 (Energy Cost)

* 卡片堆疊順序不僅影響效果，還會影響 **冷卻時間 (CD)**。
* **公式建議**：每一張後置卡片都會額外增加該技能  的總冷卻時間。這會逼玩家思考：是要一個「超強但 10 秒發一次」的技能，還是「三個普通但連發」的技能。

### B. 邊際效益遞減

* 對於 `Speed` 或 `Radius` 等物理參數，設定 **硬上限 (Hard Cap)**。
* 例如：電球旋轉速度最快不能超過 ，否則會造成碰撞偵測失效。

### C. 關卡屬性剋制

* **毒霧** 對建築物或機械怪無效。
* **魅惑** 對精英怪機率減半。
* **冰錐** 在「極寒關卡」傷害加倍，但在「岩漿關卡」會快速消融（距離縮短）。

---

## 4. 遊戲架構：三層數據傳遞

為了讓 Agent 能夠理解這套複雜的系統，開發時需區分三種數據流：

1. **藍圖數據 (Blueprint)**：卡片的原始定義（JSON）。
2. **演化數據 (Evolution)**：玩家在卡槽中排列的「卡片序列」。
3. **運行實例 (Runtime Instance)**：戰鬥中根據演化數據生成的 `GameObject`。

---
---
---
這是一份為開發者（Agent）量身打造的**核心系統企劃書**。這份文件抽離了細雜的討論，直接定義遊戲最核心的**「順序性卡片堆疊系統」**。

---

# 專案：Survivor-X 核心卡片系統企劃

## 1. 核心設計哲學：順序依賴 (Sequential Stacking)

不同於一般遊戲將所有加成「加總」後套用，本遊戲的技能強度取決於**卡片放入的先後順序**。這將卡片組合從單純的數值遊戲轉變為**「技能邏輯編寫」**。

---

## 2. 系統基礎構架

### A. 槽位限制 (Slot System)

* 主角擁有 **3 個固定卡槽**。
* 每個卡槽的第一張卡必須是**「主動技能卡 (Base Card)」**。
* 後續疊加的為**「強化修正卡 (Modifier Card)」**。

### B. 核心邏輯：快照機制 (The Snapshot Rule)

系統在處理卡片序列時，會由左至右逐一讀取：

1. **主動技能卡**：產生一個「母體 (Parent Instance)」與其「當前屬性快照」。
2. **數值強化卡**：修改目前的「快照」數值。
3. **衍生產生卡 (如：數量+1)**：依照**當下的快照**複製出一份「子體 (Child Instance)」。
4. **關鍵點**：後續加入的強化卡只會修改「母體」，**不會回溯修改已經產生的「子體」**。

---

## 3. 卡片庫與參數定義表

所有技能共享一套參數池，方便未來透過標籤 (Tag) 進行全域擴充。

### 主要參數池 (Parameter Pool)

* **物理類**：`Damage` (傷害), `Speed` (移動/旋轉速度), `Radius` (範圍/半徑), `Duration` (持續時間)。
* **行為類**：`Count` (數量), `Pierce` (穿透次數), `CD` (冷卻時間), `Angle` (扇形角度)。
* **特殊類**：`Knockback` (擊退), `Chance` (機率), `Slow%` (減速比)。

### 卡片類型詳解

| 類型 | 名稱 | 主要機制 | 策略亮點 (順序影響) |
| --- | --- | --- | --- |
| **發射** | **冰錐** | 直線貫穿攻擊 | 先加穿透再加數量 = 全彈貫穿；反之則僅主彈貫穿。 |
| **防禦** | **電球** | 環繞主角旋轉 | 先加半徑再加數量 = 遠距大圈；後加數量 = 內外圈防禦網。 |
| **掃蕩** | **光束** | 定點/追蹤射線 | 可造成「一粗多細」或「全數粗大」的火力區別。 |
| **區域** | **毒霧** | 腳下 AoE 傷害 | 先加範圍再加數量 = 雙重超大毒區。 |
| **突圍** | **衝撞** | 高速位移攻擊 | 先加距離再加數量 = 連續短衝 vs 長距單衝。 |
| **控制** | **水球** | 囚禁敵人並耗血 | 先加容量可一次關住更多怪。 |
| **聚怪** | **黑洞** | 強力吸引中心點 | 先加吸力可確保後續產生的副黑洞也能有效聚怪。 |
| **清理** | **連鎖閃電** | 跳躍式彈射傷害 | 決定每一跳的衰減率與跳躍次數。 |
| **戰術** | **魅惑** | 敵方轉為我方 | 先加強度再加數量 = 精英軍團 vs 雜魚海。 |

---

## 4. 戰鬥與成長循環 (The Loop)

### 局內成長 (Internal)

* **等級與臨時卡**：擊殺怪物獲得經驗。升級時，玩家從隨機三張卡中選一。
* **位置權重**：玩家必須決定將這張卡「插入」哪一個技能槽位的末端。
* **冷卻平衡**：每疊加一張卡，該技能的冷卻時間 () 會微幅增加，防止單一技能無限膨脹。

### 局外提取 (Persistence)

* **提取機制**：通關後，玩家可以從該局使用的「臨時卡片」中**挑選一張**永久保留。
* **戰前配置**：進入關卡前，玩家可從永久倉庫中挑選卡片填滿 3 個初始槽位。

---

## 5. 開發技術指南 (For Agent)

### A. 數據結構 (TypeScript)

```typescript
interface SkillInstance {
  id: string;
  baseStats: Stats; // 初始數值
  modifiers: Modifier[]; // 存放卡片序列
  runtimeSnapshots: Stats[]; // 最終生成的各個子體數據
}

```

### B. 手機端適配 (Mobile UX)

* **操作方案**：左手虛擬搖桿 (Joystick) 負責移動。
* **自動鎖定**：技能優先朝最近敵人發射（部分技能如「崩落」可透過長按拖曳指定位置）。
* **UI 佈局**：卡片序列採橫向排列，點擊可即時查看該序列產生的「最終預期傷害」。

---

### 下一個步驟建議：

這份企劃已完成核心邏輯的統整。**您希望我現在為您撰寫哪一部分的「第一版代碼實作」？**

1. **技能序列演化邏輯 (TS)**：實作「先疊加、後產生」的數值運算引擎。
2. **虛擬搖桿移動控制 (React)**：實作手機端流暢的位移感與碰撞基礎。
3. **關卡設定檔結構 (JSON)**：設計第一個具備「移動到指定點」任務的關卡模板。

---
---
---

1. 技能類型與參數擴充表
我將參數分為：主動屬性（數值）與 行為邏輯（機制）。

技能名稱,核心參數 (Parameters),特殊機制 (Mechanics),順序堆疊的玩法想像
毒霧,"radius, dot_damage, slow_rate, tick_rate",區域持續傷害 (AoE DOT),先疊「範圍」，再疊「生成數量」：你會得到一個巨大的毒雲，旁邊跟著一個小毒雲。
衝撞,"dash_distance, impact_damage, invincible_time",位移型攻擊,先疊「距離」，再疊「傷害」：你會衝很遠，但只有衝刺起點處的傷害最高。
風刃,"angle, falloff_ratio (隨距離衰減率), speed",扇形、遠程衰減,先疊「衰減優化」，再疊「數量」：主風刃飛很遠還很強，副風刃飛一半就消失。
水球,"capture_limit (困住數量), dot_damage",限制行動 + 高傷,先疊「困住數量」，再疊「持續時間」：可以一次關住一群怪很久，讓你可以去處理別的怪。
崩落,"cast_range, trap_duration, tick_damage",定點陷阱,先疊「施法距離」，再疊「範圍」：可以在遠處放一個小洞，或者在腳下放一個大洞。
詛咒,"kill_chance, cooldown, target_count",概率即死,先疊「概率」，再疊「目標數」：主目標幾乎必死，分裂出來的次目標則隨緣。
魅惑,"charm_duration, atk_buff (被魅惑怪的加成)",敵友轉換,先疊「攻擊加成」，再疊「持續時間」：讓那隻怪瞬間變超強，但很快就變回敵人。


2.「順序堆疊」的深度核對：策略範例
我們用**「毒霧」**來做一次深度邏輯核對。假設你現在有三個位置可以放加成卡：

策略 A (廣域擴張)：毒霧 + 範圍增加 + 產生副本

結果：你腳下出現一個超級大的毒雲，並且因為「產生副本」是在範圍增加之後，它會複製目前這個「大毒雲」的狀態，所以你會得到兩個大毒雲。

策略 B (精準打擊)：毒霧 + 產生副本 + 範圍增加

結果：你先產生了一個副本（此時兩者都是小毒雲），然後「範圍增加」只作用於主體。你會得到一個大毒雲 + 一個小毒雲。

為什麼要這樣設計？ 這樣可以逼玩家思考：我是要一個極限強大的單體，還是要一堆性能平平的群體？這對於「手機遊玩」這種零碎時間的操作來說，思考「怎麼插卡」本身就是一種樂趣。
---
